动归总结：
动归的过程为，每次决策依赖于当前状态，又随即引起状态的转移，多阶段最优化决策解决问题。基本思想同分治法类似，将待求解的问题分解为若干个子问题，按顺序求解子阶段。注意：适合动归求解的问题，经分解后得到的子问题往往不是相互独立的。
基本步骤：
（1）划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段，注意划分后的阶段一定是有序的
（2）确定状态和状态变量：将问题发展到各个阶段所处于的各种客观情况用不同状态表示出来
（3）确定决策并写出状态转移方程
（4）寻找边界条件

f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}

经典模型：
（1）过桥问题，每次过1-2个人，只有一个手电筒，每次过桥的人需要把手电筒带回，i号过桥的时间为T[i]，求minTime
假设前i个人过河话费的最少时间为opt[i]，考虑前i-1和i-2个人过河的情况
1.河这边还有一个人时，选取对岸速度最快的送来手电筒之后两人一起过去，opt[i] = opt[i - 1] + T[1] + T[i] (T[i] > T[1] 故取最大时间)
2.河边还有两个人时，假设分别为T[i]和T[2]，让对岸最快的人送来手电筒之后，这两个人同时过去，再让速度较快的人送来手电筒之后和1一起过去，时间为
opt[i] = opt[i - 2] + T[1] + T[i] + T[2]

（2）给定长度为n的字符串A，求插入最少多少字符串使得它变成一个回文串
当A是一个回文串时，在A两边添加相同字符它仍是一个回文串，用d[i][j]表示使这个字符串变成回文串所需要添加的最少的字符数，对于A[i] == A[j], 
d[i][j] = d[i + 1][j - 1]；对于A[i] != A[j]，有两种决策：
1.在A[j]后面添加一个字符A[i]
2.在A[i]前面添加一个字符A[j]
状态转移方程为 d[i][j] = min{d[i + 1][j], d[i][j - 1]} + 1 （区间长度会增加1）

（3）背包问题
N种物品，每种物品1件，一个容量为V的背包，放入第i种物品耗费空间Ci，得到的价值为Wi，使价值总和最大
令f[i][v]表示前i种物品恰好放入v可以获得的最大值，那么可以选择第i个物品放或者不放
f[i][v] = max{f[i-1][v-ci] + wi, f[i-1][v]} 


Leetcode:
1. 